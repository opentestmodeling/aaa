/*
 * generated by Xtext 2.15.0
 */
package org.opentestmodeling.vstep.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.opentestmodeling.vstep.ngt.DataBinding;
import org.opentestmodeling.vstep.ngt.DataList;
import org.opentestmodeling.vstep.ngt.DataPackage;
import org.opentestmodeling.vstep.ngt.Dependency;
import org.opentestmodeling.vstep.ngt.Inheritance;
import org.opentestmodeling.vstep.ngt.Model;
import org.opentestmodeling.vstep.ngt.NgtPackage;
import org.opentestmodeling.vstep.ngt.NodeChain;
import org.opentestmodeling.vstep.ngt.QualityRisk;
import org.opentestmodeling.vstep.ngt.Relation;
import org.opentestmodeling.vstep.ngt.StringList;
import org.opentestmodeling.vstep.ngt.TargetChain;
import org.opentestmodeling.vstep.ngt.TestContainer;
import org.opentestmodeling.vstep.ngt.TestTarget;
import org.opentestmodeling.vstep.ngt.TestViewpoint;
import org.opentestmodeling.vstep.ngt.TopLevelImport;
import org.opentestmodeling.vstep.ngt.TypeDef;
import org.opentestmodeling.vstep.ngt.TypeImport;
import org.opentestmodeling.vstep.ngt.TypeInterface;
import org.opentestmodeling.vstep.services.NgtGrammarAccess;

@SuppressWarnings("all")
public class NgtSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private NgtGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == NgtPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case NgtPackage.DATA_BINDING:
				sequence_DataBinding(context, (DataBinding) semanticObject); 
				return; 
			case NgtPackage.DATA_LIST:
				sequence_DataList(context, (DataList) semanticObject); 
				return; 
			case NgtPackage.DATA_PACKAGE:
				sequence_DataPackage(context, (DataPackage) semanticObject); 
				return; 
			case NgtPackage.DEPENDENCY:
				sequence_Dependency(context, (Dependency) semanticObject); 
				return; 
			case NgtPackage.INHERITANCE:
				sequence_Inheritance(context, (Inheritance) semanticObject); 
				return; 
			case NgtPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case NgtPackage.NODE_CHAIN:
				sequence_NodeChain(context, (NodeChain) semanticObject); 
				return; 
			case NgtPackage.QUALITY_RISK:
				sequence_QualityRisk(context, (QualityRisk) semanticObject); 
				return; 
			case NgtPackage.RELATION:
				sequence_Relation(context, (Relation) semanticObject); 
				return; 
			case NgtPackage.STRING_LIST:
				sequence_StringList(context, (StringList) semanticObject); 
				return; 
			case NgtPackage.TARGET_CHAIN:
				sequence_TargetChain(context, (TargetChain) semanticObject); 
				return; 
			case NgtPackage.TEST_CONTAINER:
				sequence_TestContainer(context, (TestContainer) semanticObject); 
				return; 
			case NgtPackage.TEST_TARGET:
				sequence_TestTarget(context, (TestTarget) semanticObject); 
				return; 
			case NgtPackage.TEST_VIEWPOINT:
				sequence_TestViewpoint(context, (TestViewpoint) semanticObject); 
				return; 
			case NgtPackage.TOP_LEVEL_IMPORT:
				sequence_TopLevelImport(context, (TopLevelImport) semanticObject); 
				return; 
			case NgtPackage.TYPE_DEF:
				sequence_TypeDef(context, (TypeDef) semanticObject); 
				return; 
			case NgtPackage.TYPE_IMPORT:
				sequence_TypeImport(context, (TypeImport) semanticObject); 
				return; 
			case NgtPackage.TYPE_INTERFACE:
				sequence_TypeInterface(context, (TypeInterface) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     DataBinding returns DataBinding
	 *
	 * Constraint:
	 *     (dataList=DataList stereotype=STEREOTYPE_STRING? viewpoint=[TestViewpoint|STRING])
	 */
	protected void sequence_DataBinding(ISerializationContext context, DataBinding semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataList returns DataList
	 *
	 * Constraint:
	 *     (elements+=QualifiedName elements+=QualifiedName*)
	 */
	protected void sequence_DataList(ISerializationContext context, DataList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataPackage returns DataPackage
	 *
	 * Constraint:
	 *     (name=ID description=STRING? entries+=DataElement*)
	 */
	protected void sequence_DataPackage(ISerializationContext context, DataPackage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeConnection returns Dependency
	 *     Dependency returns Dependency
	 *
	 * Constraint:
	 *     (stereotype=STEREOTYPE_STRING? dependsOn=TestNode)
	 */
	protected void sequence_Dependency(ISerializationContext context, Dependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeConnection returns Inheritance
	 *     Inheritance returns Inheritance
	 *
	 * Constraint:
	 *     (stereotype=STEREOTYPE_STRING? (subClass=TestViewpoint | ref=[TestViewpoint|STRING]))
	 */
	protected void sequence_Inheritance(ISerializationContext context, Inheritance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         imports+=TopLevelImport+ | 
	 *         (
	 *             imports+=TopLevelImport+ 
	 *             (testElements+=TestNode | testElements+=Chain | testElements+=TestContainer | dataPackages+=DataPackage | dataBindings+=DataBinding)+
	 *         )
	 *     )?
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Chain returns NodeChain
	 *     NodeChain returns NodeChain
	 *
	 * Constraint:
	 *     (start=TestNode (connections+=Relation | connections+=Dependency) connections+=NodeConnection*)
	 */
	protected void sequence_NodeChain(ISerializationContext context, NodeChain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QualityRisk returns QualityRisk
	 *
	 * Constraint:
	 *     (importance=INT severity=INT)
	 */
	protected void sequence_QualityRisk(ISerializationContext context, QualityRisk semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NgtPackage.Literals.QUALITY_RISK__IMPORTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NgtPackage.Literals.QUALITY_RISK__IMPORTANCE));
			if (transientValues.isValueTransient(semanticObject, NgtPackage.Literals.QUALITY_RISK__SEVERITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NgtPackage.Literals.QUALITY_RISK__SEVERITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getQualityRiskAccess().getImportanceINTTerminalRuleCall_2_0(), semanticObject.getImportance());
		feeder.accept(grammarAccess.getQualityRiskAccess().getSeverityINTTerminalRuleCall_5_0(), semanticObject.getSeverity());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeConnection returns Relation
	 *     Relation returns Relation
	 *
	 * Constraint:
	 *     (stereotype=STEREOTYPE_STRING? source=TestNode)
	 */
	protected void sequence_Relation(ISerializationContext context, Relation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StringList returns StringList
	 *
	 * Constraint:
	 *     (elements+=STRING_OR_NUMBER elements+=STRING_OR_NUMBER*)?
	 */
	protected void sequence_StringList(ISerializationContext context, StringList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Chain returns TargetChain
	 *     TargetChain returns TargetChain
	 *
	 * Constraint:
	 *     (start=TestTarget connections+=Inheritance connections+=NodeConnection*)
	 */
	protected void sequence_TargetChain(ISerializationContext context, TargetChain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestContainer returns TestContainer
	 *
	 * Constraint:
	 *     (name=STRING (elements+=TestContainer | elements+=TestNode)*)
	 */
	protected void sequence_TestContainer(ISerializationContext context, TestContainer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestNode returns TestTarget
	 *     TestTarget returns TestTarget
	 *
	 * Constraint:
	 *     (name=TESTTARGET_STRING stereotype=STEREOTYPE_STRING?)
	 */
	protected void sequence_TestTarget(ISerializationContext context, TestTarget semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestNode returns TestViewpoint
	 *     TestViewpoint returns TestViewpoint
	 *
	 * Constraint:
	 *     (name=STRING testItems=StringList? qualityRisk=QualityRisk? coverage=STRING? stereotype=STEREOTYPE_STRING?)
	 */
	protected void sequence_TestViewpoint(ISerializationContext context, TestViewpoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopLevelImport returns TopLevelImport
	 *
	 * Constraint:
	 *     importURI=STRING
	 */
	protected void sequence_TopLevelImport(ISerializationContext context, TopLevelImport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NgtPackage.Literals.TOP_LEVEL_IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NgtPackage.Literals.TOP_LEVEL_IMPORT__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTopLevelImportAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataElement returns TypeDef
	 *     TypeDef returns TypeDef
	 *
	 * Constraint:
	 *     (name=ID typeSymbol=ID)
	 */
	protected void sequence_TypeDef(ISerializationContext context, TypeDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NgtPackage.Literals.TYPE_DEF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NgtPackage.Literals.TYPE_DEF__NAME));
			if (transientValues.isValueTransient(semanticObject, NgtPackage.Literals.TYPE_DEF__TYPE_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NgtPackage.Literals.TYPE_DEF__TYPE_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeDefAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTypeDefAccess().getTypeSymbolIDTerminalRuleCall_2_0(), semanticObject.getTypeSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataElement returns TypeImport
	 *     TypeImport returns TypeImport
	 *
	 * Constraint:
	 *     importURI=STRING
	 */
	protected void sequence_TypeImport(ISerializationContext context, TypeImport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NgtPackage.Literals.TYPE_IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NgtPackage.Literals.TYPE_IMPORT__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeImportAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataElement returns TypeInterface
	 *     TypeInterface returns TypeInterface
	 *
	 * Constraint:
	 *     (name=ID super=ID? (imports+=TypeImport | refs+=QualifiedName)*)
	 */
	protected void sequence_TypeInterface(ISerializationContext context, TypeInterface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
